---
title: Uniswap V3 CPMM  # 글 제목
date: 2026-01-28 00:00:00 +0900 # 작성 시간
categories: [web3, DEX] # 카테고리
tags: [web3, uniswap, CPMM]     # 태그
math: true
---

## CPMM 예시 및 키워드 정리
아래가 CPMM의 식이다.
$$
X * Y = K
$$

```
X: x 토큰의 리저브 개수
Y: y 토큰의 리저브 개수
K: x/y 풀의 리저브 개수
```

![](/assets/img/image.png){:width="50%" height="50px"}


$X: 1,000, Y: 4,000$ 라고 하면 $K: 4,000,000$ 로 고정이 된다.\
이후 새로운 유동성이 공급되거나 기존의 유동성이 빠져나갈때 값이 변할 수 있다.

여기서 Uniswap은 토큰 스왑의 기준이 되는 **토큰 유동성**을 다음과 같이 정의한다.

$$
L = \sqrt{X * Y}
$$

따라서 위의 예시에 따르면 $L$ 값은

$$
L = \sqrt{X * Y} = \sqrt{1,000 * 4,000} = 2,000
$$

여기서 $L^2$ 은 위에서 확인한 $K$ 와 같다는 것을 알 수 있다.
또 기억해야할 부분은 $L^2$는 **풀 전체의 유동성**을 의미하고, $L$은 풀 구성하는 토큰 한 개에 대한 **기준 유동성**을 의미한다.

이제 **토큰의 유동성 가치**를 알아보자.\
$P_x$ 를 X의 가치(가격)이라 하면, x 토큰의 가치는 다음과 같다.

$$
L_x = X * P_x
$$

y 토큰도 아래와 같다.
$$
L_y = Y * P_y
$$

이제 $L_v$를 풀의 토큰 유동성 가치라고 하면 다음과 같다.

$$
L_v = L * \sqrt{P}
$$


$\sqrt{P}$ 는 토큰 한 개에 대한 풀의 기준 가격을 의미한다. 풀에 유동성이 공급될 때는 동일 한 가치를 같도록 x, y 토큰을 1:1로 예치를 하여 아래 식이 성립된다.

$$
L_v = L_x = L_y
$$

이를 통해서 앞의 식을 다시 정리해보면 아래와 같다.\

$$
\begin{aligned}
&L_v^2 = L_x * L_y = (X * P_x) * (Y * P_y) = (X * Y) * (P_x * P_y) \\
&L_v = \sqrt{X * Y} * \sqrt{P_x * P_y}
\end{aligned}
$$

그러면 아래가 성립하고

$$
\begin{aligned}
&L = \sqrt{X * Y}\\
&\sqrt{P} = \sqrt{P_x * P_y}
\end{aligned}
$$

그러면 풀의 기준 가격인 $\sqrt{P}$ 에 대해 아래처럼 정리할 수 있다.

$$
P=P_x * P_y\\
$$

$$
\therefore \sqrt{P} = P_x\quad or\quad P_y
$$

그럼 다시 위 예시로 계산을 해보자.

$$
\begin{aligned}
&P_x = \frac{L_x}{X} = \frac{2,000}{1,000} = 2\ \$ \\
&P_y = \frac{L_x}{Y} = \frac{2,000}{4,000} = 0.5\ \$
\end{aligned}
$$

풀의 기준 가격을 결정하기 위해서는 기준으로 삼을 토큰을 정해야한다. 여기서는 x를 기준 토큰으로 삼아보자. ($\sqrt{P} = P_x$)

$$
\sqrt{P} = P_x = \frac{L_x}{X} = \frac{\sqrt{X*Y}}{X} = \sqrt{\frac{Y}{X}}\\
$$

$$
\therefore \sqrt{P} = \sqrt{\frac{Y}{X}}
$$

바로 이 $\sqrt{P}$ 가 풀의 현재 상태를 나타내는 가장 기초적인 지표이다. Uniswap V3, V4는 reserve 값을 저장하지 않고 수학적 효율성과 정밀도를 위해 $\sqrt{P}$ 와 $L$ 을 상태 변수로써 활용한다.

### Reserve 유도
$\sqrt{P}$ 와 $L$ 을 가지고 토큰의 reserve 개수를 나타내는 $X, Y$ 표현할 수 있다.

$$
\begin{aligned}
&L=\sqrt{X*Y}\\
&\sqrt{P} = \sqrt{\frac{X}{Y}}\\
&\frac{L}{\sqrt{P}} = \sqrt{X*Y}*\sqrt{\frac{X}{Y}} = X\\
&L*\sqrt{P} = \sqrt{X*Y}*\sqrt{\frac{Y}{X}} = Y
\end{aligned}
$$

이를 통해 uniswap v3, V4는 직접 reserve 변수 값을 저장하지 않고 상태만을 저장하게 된다.\
V3는 CPMM 함수가 아래처럼 바뀐다.

$$
L^2 = (X+\frac{L}{\sqrt{P_b}}) * (Y + L * \sqrt{P_a})
$$

지금까지 각 변수들에 대해 공부했으니, V3에서 들어온 Concentrated liquidity에서 어떻게 스왑이 일어나는지를 알아보자.

## Concentradted Liquidity Swap

![alt text](/assets/img/image-1.png){:width="50%" height="50px"}

평행 이동 (Parallel Shifting)v3는 특정 구간($P_a, P_b$)에서 자산이 0이 되게 만들어야 합니다.\
이를 위해 실제 자산($x, y$)에 가상의 양을 더해 수식을 강제로 맞춥니다.

$$
(x + \frac{L}{\sqrt{P_b}})(y + L\sqrt{P_a}) = L^2
$$

왜 더하는가? (왼쪽/아래쪽 이동):원래 곡선($x \cdot y = L^2$)은 $x=0$이 되려면 $y$가 무한대여야 합니다.\
하지만 우리는 가격이 $P_b$일 때(즉, $y$가 특정 유한한 값일 때) $x$를 0으로 만들고 싶습니다.\
따라서 실제 $x$에 $\frac{L}{\sqrt{P_b}}$만큼의 **가상 값**을 더해줍니다.\ 
이렇게 하면 실제 $x$가 0이 되어도 공식상으로는 여전히 양수($\frac{L}{\sqrt{P_b}}$)가 되어 수학적 성립이 가능해집니다.\
그래프 관점에서는 곡선을 왼쪽($x$축 음의 방향)과 아래쪽($y$축 음의 방향)으로 밀어낸 것과 같습니다.\
이 이동을 통해 곡선의 일부분이 $x$축과 $y$축에 닿게(자산이 0이 되게) 만드는 것입니다.

각 구간별로 유한한 유동성을 가지며, Uniswap V2와 동일하게 작동됩니다. V3는 여러개의 작은 V2 페어로 이루어져있습니다.

## Tick
Uniswap V3은 구간을 나누어 유동성을 공급한다. 여기에서 V3는 구간을 Traking하기 위해 Tick을 사용한다.
각 구간을 엔지니어링 측면에서 다루기 위해 도입된 개념이다.\
\
$\sqrt{P}$ 는 fixed point로 Q64.96을 따른다. 실제로 uint160을 사용한다.

## Providing Liquidity
### Knowledge required
1. 유동성 공급시 가격 $P$ 값이 변하면 안된다.
2. Swap 시에는 $L$ 값이 변하면 안되지만, 유동성 공급시에는 변할 수 있다.

\
유동성을 공급하는 과정에서 공급하는 가격 범위에 따라 3가지의 경우가 있다.

1. $P_b < P_c$ \
(현재 가격이 범위보다 높은 경우)\
    - 가격이 범위보다 높으므로 하락해야 범위 안으로 들어온다.
    - 가격 하락시에는 Pool이 y 토큰을 팔아야하니, 사용자는 y 토큰만 예치하면 된다.
    - $P_a$ 에서 $P_b$로 상승하는 동안, 사용자가 예치한 $\Delta y$ 값이 전부 x로 바뀌려면 어느정도의 유동성 두께($L$)가 필요한지 계산한다.

2. $P_a > P_c$\
(현재 가격이 범위보다 낮은 경우)
    - 가격이 범위보다 낮으므로 상승해야 범위 안으로 들어온다.
    - 가격 상승시에는 Pool이 x 토큰을 팔아야하니, 사용자는 x 토큰만 예치하면 된다.
    - $P_b$ 에서 $P_a$로 하락하는 동안, 사용자가 예치한 $\Delta x$ 값이 전부 y로 바뀌려면 어느정도의 유동성 두께($L$)가 필요한지 계산한다.
3. $P_a < P_c < P_b$\
(현재 가격이 범위 안에 있는 경우)
    - 가격이 범위 안에 있으니 2가지의 $L$ 값을 구해서 최소값을 찾아야한다.\
    (만약 최대값 $L$을 사용한다면 한 쪽의 유동성이 많아져 $P$ 값이 변하게 된다)
        - $P_c$ 에서 $P_b$ 로 상승하는 과정의 사용자가 예치한 $\Delta y$ 값이 전부 x로 바뀌는데 사용되는 유동성 $L_b$
        - $P_c$ 에서 $P_a$ 하락하는 과정의 사용자가 예치한 $\Delta y$ 값이 전부 x로 바뀌는데 사용되는 유동성 $L_a$
    - $L_a,\ L_b$ 중에 작은 걸 선택해 그에 맞는 x, y 토큰을 예치하면 된다.


![3번째로 가격이 범위 안에 있는 경우](/assets/img/image-2.png){:width="50%" height="50px"}


```solidity
function getLiquidityForAmounts(
    uint160 sqrtPriceX96,   // 현재 가격 (sqrt(P))
    uint160 sqrtPriceAX96,  // 하한선 (sqrt(Pa))
    uint160 sqrtPriceBX96,  // 상한선 (sqrt(Pb))
    uint256 amount0,        // 가져온 x 토큰 양
    uint256 amount1         // 가져온 y 토큰 양
) internal pure returns (uint128 liquidity) {
    // ... 가격 순서 정렬 로직 생략 ...

    if (sqrtPriceX96 <= sqrtPriceAX96) {
        // 상황 1: 현재 가격이 범위 아래에 있을 때 (P <= Pa)
        liquidity = getLiquidityForAmount0(sqrtPriceAX96, sqrtPriceBX96, amount0);
    } else if (sqrtPriceX96 < sqrtPriceBX96) {
        // 상황 2: 현재 가격이 범위 안에 있을 때 (Pa < P < Pb)
        uint128 liquidity0 = getLiquidityForAmount0(sqrtPriceX96, sqrtPriceBX96, amount0);
        uint128 liquidity1 = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceX96, amount1);

        liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
    } else {
        // 상황 3: 현재 가격이 범위 위에 있을 때 (P >= Pb)
        liquidity = getLiquidityForAmount1(sqrtPriceAX96, sqrtPriceBX96, amount1);
    }
}
```
실제 Uniswap 코드로 각 경우에 맞게 유동성을 계산하는 과정이다.




## References
[hyun-jeong.medium.com/cpmm-이해하기](https://hyun-jeong.medium.com/uniswap-series-2-cpmm-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-4a82de8aba9)

[hyun-jeong.medium.com/유니스왑-v3-톺아보기](https://hyun-jeong.medium.com/uniswap-series-3-%EC%9C%A0%EB%8B%88%EC%8A%A4%EC%99%91-v3-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0-a058235823e3)

[uniswapv3book](https://uniswapv3book.com/index.html)